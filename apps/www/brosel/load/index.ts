import chokidar from "chokidar";
/**
 * This file is used to load the server, client and assets into the bun serve() function.
 * Please do not edit this file, unless you know what you're doing.
 */

import { readdir } from "node:fs/promises";
import { $, type BunRequest } from "bun";
import { z } from "zod";
import { getConfig } from "../config/get-config";
import { hydrationTemplate } from "../templates";

export const loadAssets = async () => {
	const config = await getConfig();
	const assets = new Bun.Glob(`${process.cwd()}/${config.assetsDir}/**/*`);
	const files: { path: string; handler: () => Response }[] = [];
	for await (const file of assets.scan()) {
		files.push({
			path: file.replace(`${process.cwd()}/${config.assetsDir}/`, ""),
			handler: () => {
				return new Response(Bun.file(file));
			},
		});
	}

	const assetsWatcher = chokidar.watch(config.assetsDir);
	assetsWatcher.on("all", async (path, stats) => {
		const relativePath = path.replace(
			`${process.cwd()}/${config.assetsDir}/`,
			"",
		);

		if (await Bun.file(path).exists()) {
			// Update or add file
			files.push({
				path: relativePath,
				handler: () => {
					return new Response(Bun.file(path));
				},
			});
		} else {
			// Remove file
			const index = files.findIndex((file) => file.path === relativePath);
			if (index !== -1) {
				files.splice(index, 1);
			}
		}
	});

	const assetsObject = Object.fromEntries(
		files.map((file) => [file.path, file.handler]),
	);

	assetsObject["/assets/styles.css"] = () => {
		return new Response(Bun.file("./.brosel/out.css"));
	};

	return assetsObject;
};

type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

export async function loadRoutes() {
	const config = await getConfig();
	const router = new Bun.FileSystemRouter({
		style: "nextjs",
		dir: `${process.cwd()}/${config.routesDir}`,
	});

	const routes: {
		path: string;
		handler: Partial<
			Record<HttpMethod, (req: Request) => Response | Promise<Response>>
		>;
	}[] = [];

	for await (const [path] of Object.entries(router.routes)) {
		const importPath = `${process.cwd()}/src/routes${path}.ts`;

		const mod = await import(importPath);

		const route = mod.default as {
			path: string;
			routes: Partial<
				Record<HttpMethod, (req: Request) => Response | Promise<Response>>
			>;
		};

		const handlerSchema = z.object({
			GET: z.function().args(z.instanceof(Request)).returns(z.any()).optional(),
			POST: z
				.function()
				.args(z.instanceof(Request))
				.returns(z.any())
				.optional(),
			PUT: z.function().args(z.instanceof(Request)).returns(z.any()).optional(),
			DELETE: z
				.function()
				.args(z.instanceof(Request))
				.returns(z.any())
				.optional(),
		});

		const routeSchema = await z
			.object({
				path: z.string(),
				routes: handlerSchema,
			})
			.safeParseAsync(route);

		if (!routeSchema.success) {
			console.log(routeSchema.error.issues);
			throw new Error("Failed to parse route");
		}

		routes.push({
			path: route.path,
			handler: route.routes,
		});
	}

	const routesObject = Object.fromEntries(
		routes.map((route) => [route.path, route.handler]),
	);

	return routesObject;
}

async function findPageFilesRecursively(
	currentDirPath: string,
	collectedPaths: { clientPath: string; serverPath: string }[],
) {
	const entries = await readdir(currentDirPath, { withFileTypes: true });

	for (const entry of entries) {
		const fullPath = `${currentDirPath}/${entry.name}`;
		if (entry.isFile() && entry.name.endsWith(".client.tsx")) {
			const fileName = entry.name.split(".")[0];
			const serverFilePath = `${currentDirPath}/${fileName}.tsx`;
			const serverFile = Bun.file(serverFilePath);

			if (await serverFile.exists()) {
				collectedPaths.push({
					clientPath: fullPath,
					serverPath: serverFilePath,
				});
			} else {
				// If a client file exists but its corresponding server file doesn't, it's an error.
				throw new Error(`Server file not found for client file: ${fullPath}`);
			}
		} else if (entry.isDirectory()) {
			await findPageFilesRecursively(fullPath, collectedPaths);
		}
	}
}

interface Page {
	path: string;
	handler: (req: BunRequest<string>) => Promise<Response>;
}

export async function getClientAndServerPagePaths() {
	const pageRoot = `${process.cwd()}/src/pages`;
	const collectedPaths: { clientPath: string; serverPath: string }[] = [];
	await findPageFilesRecursively(pageRoot, collectedPaths);
	return collectedPaths;
}

/**
 * Get the pages from the configured `pages` directory. This function loads all of the pages, creates
 * a client script for react hydration, and returns an object with the path and the handler for the bun server.
 * @returns Object with the path and the handler for the bun server.
 */
export async function loadPages() {
	const config = await getConfig();

	const pages: Page[] = [];

	const files = await getClientAndServerPagePaths();

	for (const page of files) {
		// get url with the path
		const routePath = page.clientPath
			.split(config.pagesDir)[1]
			?.replace("/index.client.tsx", "")
			.replace(".client.tsx", "");

		if (
			!(
				await import(
					`${process.cwd()}/${config.pagesDir}${page.clientPath.split("/pages")[1]}`
				)
			).default
		) {
			throw new Error(
				`Client component not found for route: ${routePath}. You have to export a default react component.`,
			);
		}

		await Bun.write(
			`${process.cwd()}/.brosel/tsx/client${routePath?.replace(/\//g, "-")}.tsx`,
			hydrationTemplate(page.clientPath),
		);

		const build = await Bun.build({
			entrypoints: [
				`${process.cwd()}/.brosel/tsx/client${routePath?.replace(/\//g, "-")}.tsx`,
			],
			outdir: `${process.cwd()}/.brosel`,
			minify: true,
			target: "browser",
		});

		if (!build) {
			throw new Error(
				`We couldn't transpile the client file: ${page.clientPath}. Please check your code for errors or other problems.`,
			);
		}

		// push server page to pages array
		const serverFunction = await import(
			`${process.cwd()}/${config.pagesDir}${page.serverPath.split("/pages")[1]}`
		);

		if (!serverFunction.default) {
			throw new Error(
				`Server function not found for route: ${routePath}. You have to export a default function which returns a "render()" function.`,
			);
		}

		pages.push({
			path: serverFunction.default.path
				? serverFunction.default.path
				: routePath === ""
					? "/"
					: (routePath as string),
			handler: serverFunction.default.handler,
		});
	}

	// create object from the array for bun server
	const pagesObject = Object.fromEntries(
		pages.map((page) => [page.path, page.handler]),
	);

	return pagesObject;
}

export const loadClientScripts = async () => {
	const files: { path: string; handler: () => Promise<Response> }[] = [];
	const folder = await readdir("./.brosel");
	for await (const file of folder) {
		if (!file.endsWith(".js")) continue;
		files.push({
			path: `/scripts/${file}`,
			handler: async () => {
				return new Response(Bun.file(`./.brosel/${file}`), {
					headers: {
						"Content-Type": "text/javascript",
					},
				});
			},
		});
	}

	const scriptsObject = Object.fromEntries(
		files.map((file) => [file.path, file.handler]),
	);

	return scriptsObject;
};
