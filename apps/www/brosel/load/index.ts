import chokidar from "chokidar";
/**
 * This file is used to load the server, client and assets into the bun serve() function.
 * Please do not edit this file, unless you know what you're doing.
 */

import { z } from "zod";
import { getConfig } from "../config/get-config";

export const loadAssets = async () => {
	const config = await getConfig();
	const assets = new Bun.Glob(`${process.cwd()}/${config.assetsDir}/**/*`);
	const files: { path: string; handler: () => Response }[] = [];
	for await (const file of assets.scan()) {
		files.push({
			path: file.replace(`${process.cwd()}/${config.assetsDir}/`, ""),
			handler: () => {
				return new Response(Bun.file(file));
			},
		});
	}

	const assetsWatcher = chokidar.watch(config.assetsDir);
	assetsWatcher.on("all", async (path, stats) => {
		const relativePath = path.replace(
			`${process.cwd()}/${config.assetsDir}/`,
			"",
		);

		if (await Bun.file(path).exists()) {
			// Update or add file
			files.push({
				path: relativePath,
				handler: () => {
					return new Response(Bun.file(path));
				},
			});
		} else {
			// Remove file
			const index = files.findIndex((file) => file.path === relativePath);
			if (index !== -1) {
				files.splice(index, 1);
			}
		}
	});

	return Object.fromEntries(files.map((file) => [file.path, file.handler]));
};

type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

export async function getRoutes() {
	const config = await getConfig();
	const router = new Bun.FileSystemRouter({
		style: "nextjs",
		dir: `${process.cwd()}/${config.routesDir}`,
	});

	const routes: {
		path: string;
		handler: Partial<
			Record<HttpMethod, (req: Request) => Response | Promise<Response>>
		>;
	}[] = [];

	for await (const [path] of Object.entries(router.routes)) {
		const importPath = `${process.cwd()}/src/routes${path}.ts`;

		const mod = await import(importPath);

		const route = mod.default as {
			path: string;
			routes: Partial<
				Record<HttpMethod, (req: Request) => Response | Promise<Response>>
			>;
		};

		const handlerSchema = z.object({
			GET: z.function().args(z.instanceof(Request)).returns(z.any()).optional(),
			POST: z
				.function()
				.args(z.instanceof(Request))
				.returns(z.any())
				.optional(),
			PUT: z.function().args(z.instanceof(Request)).returns(z.any()).optional(),
			DELETE: z
				.function()
				.args(z.instanceof(Request))
				.returns(z.any())
				.optional(),
		});

		const routeSchema = await z
			.object({
				path: z.string(),
				routes: handlerSchema,
			})
			.safeParseAsync(route);

		if (!routeSchema.success) {
			console.log(routeSchema.error.issues);
			throw new Error("Failed to parse route");
		}

		routes.push({
			path: route.path,
			handler: route.routes,
		});
	}

	const routesObject = Object.fromEntries(
		routes.map((route) => [route.path, route.handler]),
	);

	return routesObject;
}
